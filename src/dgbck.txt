import { dir, error } from 'console';
import ar_e1 from './rooms/ar_e1.js'
import ar_r2 from './rooms/ar_r2.js';
import ar_r3 from './rooms/ar_r3.js';
import ar_r4 from './rooms/ar_r4.js';
import ar_r5 from './rooms/ar_r5.js';
import ar_r6 from './rooms/ar_r6.js';
import ar_r7 from './rooms/ar_r7.js';
import ar_sh1 from './rooms/ar_sh1.js';
import ar_x1 from './rooms/ar_x1.js';
import em_r from './rooms/em_r.js'
import Phaser from 'phaser'


const N = 10; //Numero de filas
const M = 10; //Numero de columnas
const maxRooms = 15; //Maximo de habitaciones


/*//El "tablero" del mapa, en el que se van generando las habitaciones
let genMatrix;

let exitArray;
let entrance; //La entrada
let shopArray;
let deadendArray;
*/
let entranceX;
let entranceY;

let thereIsExit;
let thereIsShop;
let roomArray;


export default class Dungeongen{

    constructor(){
        
        this.init();
    }
        

    init() {

        //Inicializacion
        let dungeon = [];

        for (let i = 0; i < N; i++) {
            dungeon[i] = []; 
            for (let j = 0; j < M; j++) {
                dungeon[i][j] =  {

                    name: "em_r",
                    
                    level: "all",
                    
                    path: "../../assets/armory/em_r.tmx",
                    
                    entrance: false,
                    exit: false,
                    empty: true, //Habitacion vacia
                    deadend: false,//para saber que solo tiene una salida
                    shop:false,
                    
                    door_north: false,
                    door_south: false,
                    door_east: false,
                    door_west: false
                    
                }; 
            }
        }


        this.fillRoomArray(0);
        
        //Generamos dos cordenadas aleatorias desde donde empezar
        entranceX = Math.floor(Math.random() * N);
        entranceY = Math.floor(Math.random() * M);


        dungeon[entranceY][entranceX] = ar_e1 = {

            name: "ar_e1",
            
            level: "armory",
            
            path: "../../assets/armory/ar_e1.tmx",
            
            entrance: true,
            exit: false,
            empty: false, //Habitacion vacia
            deadend: false,//para saber que solo tiene una salida
            shop:false,
            
            door_north: true,
            door_south: true,
            door_east: true,
            door_west: true
            
        }; //Asignamos la entrada

        console.log(`Entrada generada en la casilla: ${entranceY}, ${entranceX}`);

        thereIsExit = false;
        thereIsShop = false;

        const generator = this.generate(dungeon, entranceX, entranceY);
        dungeon = generator.next().value;
        dungeon = generator.next().value;
        
        this.showMatrix(dungeon);

    
    }

    // dada una matrix, deuelve true si esto funcionaría y está terminada
    plausibleDungeon(dungeon) {
        return false;
    }

   // devuelve null si no es aplicable, y una dungeon """nueva""" si si
    applyDirection(dungeon, room, direction,x,y) {
        // deep clone: JSON.parse(JSON.stringify(dungeon))
        if (direction === 'n') {
            y -= 1;
        } else if (direction === 's') {
            y += 1;
        } else if (direction === 'e') {
            x += 1;
        } else if (direction === 'w') {
            x -= 1;
        }
        let newDungeon =[];
        newDungeon =  JSON.parse(JSON.stringify(dungeon));
        newDungeon[y][x] = room; //Deep clone si o no?
        if(this.checkIfRoomConnects(x,y,newDungeon,direction))
            return newDungeon;

        return null;
    }

    *generate(dungeon,x,y) {
        if(this.plausibleDungeon(dungeon)) {
            yield dungeon;
        }
        let directions = ['n', 's', 'e', 'w'];
        this.shuffleArray(directions); //Mezclamos las direcciones
        for(let direction of directions) {
            let validRoomArray = []; validRoomArray = this.getValidRooms(roomArray,direction,x,y)
            this.shuffleArray(validRoomArray)
            for(let room of validRoomArray ) {
            const newDungeon = this.applyDirection(dungeon, room , direction,x,y)
            if(newDungeon !== null)
                //Actualizamos coordenadas x y
                if (direction === 'n') {
                    y -= 1;
                } else if (direction === 's') {
                    y += 1;
                } else if (direction === 'e') {
                    x += 1;
                } else if (direction === 'w') {
                    x -= 1;
                }
                yield newDungeon
            }
        }
    }

    getValidRooms(roomArray,direction,x,y){

        let validRoomArray = [];

            switch(direction){
                case 'n':
                    if(!this.isCoordinateNotInsideMatrix(x,y-1)) //Si la coordenada no está dentro de la matriz 
                        return validRoomArray;
                    for(let room of roomArray){
                        if(room.door_south && (room.door_north &&  this.isRoomNotGoingToHaveUselessDoors(x,y-1))) //Si se conecta a la anterior y no lleva a la nada
                            validRoomArray.push(room);
                    }
                break;
                case 's':
                    if(!this.isCoordinateNotInsideMatrix(x,y+1)) //Si la coordenada no está dentro de la matriz 
                        return validRoomArray;
                    for(let room of roomArray){
                        if(room.door_north && (room.door_south &&  this.isRoomNotGoingToHaveUselessDoors(x,y+1)))
                            validRoomArray.push(room);
                    }

                break;
                case 'e':
                    if(!this.isCoordinateNotInsideMatrix(x+1,y)) //Si la coordenada no está dentro de la matriz 
                        return validRoomArray;
                    for(let room of roomArray){
                        if(room.door_west && (room.door_east &&  this.isRoomNotGoingToHaveUselessDoors(x+1,y)))
                            validRoomArray.push(room);
                    }

                break;
                case 'w':
                    if(!this.isCoordinateNotInsideMatrix(x-1,y)) //Si la coordenada no está dentro de la matriz 
                        return validRoomArray;
                    for(let room of roomArray){
                        if(room.door_east && (room.door_west &&  this.isRoomNotGoingToHaveUselessDoors(x-1,y)))
                            validRoomArray.push(room);
                    }

                break;
            }
        
        return validRoomArray;
    }

    checkIfRoomConnects(x,y,dungeon,direction){

        //No estoy muy orgulloso de esto xD
        if(( x-1 < 0) ||( dungeon[y][x-1].empty === false && ((dungeon[y][x].door_east === true && dungeon[y][x-1].door_west === false) || (dungeon[y][x].door_east=== false && dungeon[y][x-1].door_west === true))))
            if(direction === 'w')
                return false
        if( (x+1 >= N )||( dungeon[y][x+1].empty === false && ((dungeon[y][x].door_west === true && dungeon[y][x+1].door_east === false) || (dungeon[y][x].door_west === false && dungeon[y][x+1].door_east=== true))))
            if(direction === 'e')
                return false
        if(( y+1 >=M)  ||( dungeon[y+1][x].empty === false && ((dungeon[y][x].door_south === true && dungeon[y+1][x].door_north === false) || (dungeon[y][x].door_south === false && dungeon[y+1][x].door_north === true))))
            if(direction === 's')
                return false
        if(( y-1 <0 )|| ( dungeon[y-1][x].empty === false && ((dungeon[y][x].door_north === true && dungeon[y-1][x].door_south === false) || (dungeon[y][x].door_north === false && dungeon[y-1][x].door_south === true))))
            if(direction === 'n')
                return false

        return true;
    }


    isRoomNotGoingToHaveUselessDoors(x,y){
        //Reducimos el cuadrado efectivo de las habitaciones que apuntan en la misma direccion para evitar que sus caminos lleven a la nada.
        if( x < 1)
            return false;
        else if(x >= N-1)
            return false;
        else if(y >= M-1)
            return false;
        else if(y < 1)
            return false;

        return true;
    }


    isCoordinateNotInsideMatrix(x,y){
        if( x < 0)
            return false;
        else if(x >= N)
            return false;
        else if(y >= M)
            return false;
        else if(y < 0)
            return false;

        return true;
    }

    //Para mezclar el array de direcciones y que no siempre empiece por norte
    shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    /*

    getCandidateRoom(roomArray,k,x,y){

        if(Math.random() >= (maxRooms/(Math.max(1,Math.min(k,maxRooms)))) || !this.doesRoomNotLeadToNowhere(x,y)){ //Cuantas mas salas generadas se empiezan a cortar caminos
            let room = this.getSpecialCandidateRoom(x,y);
            if(room !== null) //Si no se puede generar una habitacion especial que genere una normal
                return room; 
        } 

        for(let i = 0; i < roomArray.length;i++){
            let index = Math.floor(Math.random() * roomArray.length);
            dungeon[y][y] = roomArray[index]; //Añadimos la habitacion candidata
            if(this.isRoomInsideMatrix(x,y)){ //Si es valida
                if( this.checkIfRoomConnects(x,y))
                    return roomArray[index]; //Devolvemos la habitacion
            }

            dungeon[x][y] = em_r; //Si no ponemos otra vez hueco vacio
        }

        return null;
    }

    getSpecialCandidateRoom(x,y){ //Las habitaciones especiales son: la tienda, la habitacion del jefe y las habitaciones sin salida

        if(thereIsExit === false) { //Priorizamos la salida

            for(let i = 0; i < exitArray.length;i++){
                let index = Math.floor(Math.random() * exitArray.length);
                dungeon[x][y] = exitArray[index];
                if(this.isRoomInsideMatrix(x,y) ){
                    if( this.checkIfRoomConnects(x,y))
                        if((Math.abs(entranceX - x) >= maxRooms / 2) || (Math.abs(entranceY - y) >= maxRooms / 2)){ //Si la salida está lo suficientemente lejos de la entrada
                            thereIsExit = true;
                            return exitArray[index]; //Devolvemos la salida
                        }
                }   

                dungeon[x][y] = em_r; //Si no ponemos otra vez hueco vacio                          
            }

        }
        if(thereIsShop === false){

            for(let i = 0; i < shopArray.length;i++){
                let index = Math.floor(Math.random() * shopArray.length);
                dungeon[x][y] = shopArray[index];
                if(this.isRoomInsideMatrix(x,y) ){
                    if( this.checkIfRoomConnects(x,y)){
                        thereIsShop = true;
                        return shopArray[index]; //Devolvemos la habitacion
                    }
                }

                dungeon[x][y] = em_r; //Si no ponemos otra vez hueco vacio
            }

        } 
        
        // Si no empezamos a cortar caminos

            for(let i = 0; i < deadendArray.length;i++){
                let index = Math.floor(Math.random() * deadendArray.length);
                dungeon[x][y] = deadendArray[index];
                if(this.isRoomInsideMatrix(x,y) ){
                    if( this.checkIfRoomConnects(x,y))
                        return deadendArray[index]; //Devolvemos la habitacion
                }
            }

            dungeon[x][y] = em_r; //Si no ponemos otra vez hueco vacio

        

        console.log(`No se pudo generar habitacion especial`);
        return null;

    }

  

    isRoomInsideMatrix(x,y){
        return ((0 <= x < N) && (0 <= y < M));
    }

    doesRoomNotLeadToNowhere(x,y){
        return ((1 <= x < N-1) && (1 <= y < M-1));
    }

    checkForValidity(){
        return thereIsExit && thereIsShop;
    }
    */
    fillRoomArray(floor){
        roomArray = [];
        if(floor === 0){ //Armeria
            //deadendArray.push(ar_e1);
            roomArray.push(ar_r2);
            roomArray.push(ar_r4);
            roomArray.push(ar_e1);
            roomArray.push(ar_x1);
            roomArray.push(ar_sh1);
            roomArray.push(ar_r3);
            roomArray.push(ar_r5);
            roomArray.push(ar_r6);
            roomArray.push(ar_r7);
            //TODO push exits y shops
        }
    }

    showMatrix(dungeon) {
        for (let i = 0; i < dungeon.length; i++) {
            let row = '';
            for (let j = 0; j < dungeon[i].length; j++) {
                if (dungeon[i][j] && dungeon[i][j].name) {
                    row += dungeon[i][j].name.padEnd(8); // Adjust the padding as needed
                } else {
                    row += '         '; // Placeholder for invalid room object
                }
            }
            console.log(row);
        }
    }

}


